"""
report.py
---------
PDF and CSV export utilities. Avoids UnicodeEncodeError on FPDF by
sanitizing strings before writing. CSV remains plain text.
"""

from fpdf import FPDF
import csv
import os
import re


def _sanitize_for_pdf(s: str) -> str:
    """
    Sanitize string for FPDF to avoid Unicode encode errors.
    Replace non-latin1 characters with closest ascii fallback where possible,
    otherwise replace with '?'.
    """
    if s is None:
        return ""
    if not isinstance(s, str):
        s = str(s)

    # Normalize common unicode punctuation to ascii equivalents
    replacements = {
        '\u2013': '-',  # en dash
        '\u2014': '-',  # em dash
        '\u2018': "'", '\u2019': "'",
        '\u201c': '"', '\u201d': '"',
        '\u00b0': ' deg',  # degree sign -> " deg"
        '—': '-', '–': '-'
    }
    for k, v in replacements.items():
        s = s.replace(k, v)

    # Remove remaining non-latin1 characters safely by encoding
    s = s.encode('latin-1', 'replace').decode('latin-1')

    # Collapse consecutive whitespace
    s = re.sub(r'\s+\n', '\n', s)
    return s


class PDFReport(FPDF):
    def header(self):
        self.set_font("Arial", "B", 14)
        self.cell(0, 10, "IS 456 Slab Design Report", ln=True, align="C")
        self.ln(5)

    def footer(self):
        self.set_y(-15)
        self.set_font("Arial", "I", 8)
        self.cell(0, 10, "Generated by IS 456 Slab Designer", align="C")


def export_pdf(result_dict, filename="slab_design_report.pdf"):
    """
    Create a simple PDF showing key results and warnings.
    Sanitize all texts to avoid Unicode issues in FPDF.
    """
    pdf = PDFReport()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.set_font("Arial", size=11)

    # Section: Summary
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 10, "Design Summary", ln=True)
    pdf.set_font("Arial", size=10)

    for key, value in result_dict.items():
        if key == "warnings" or key == "detailed_steps":
            continue
        line = f"{key}: {value}"
        pdf.multi_cell(0, 6, _sanitize_for_pdf(line))

    # Warnings
    pdf.ln(4)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "Warnings:", ln=True)
    pdf.set_font("Arial", size=10)
    if result_dict.get("warnings"):
        for w in result_dict["warnings"]:
            pdf.multi_cell(0, 6, _sanitize_for_pdf(f"- {w}"))
    else:
        pdf.multi_cell(0, 6, "No warnings.")

    # If detailed steps present, append a concise version (not too long)
    if result_dict.get("detailed_steps"):
        pdf.add_page()
        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 8, "Calculation Steps (summary)", ln=True)
        pdf.set_font("Arial", size=10)
        for step in result_dict["detailed_steps"]:
            title = _sanitize_for_pdf(step.get("title", ""))
            body = _sanitize_for_pdf(step.get("body", ""))
            pdf.multi_cell(0, 6, f"{title}")
            # show only first 6 lines per step to avoid massive PDFs
            lines = body.splitlines()
            showing = "\n".join(lines[:6])
            pdf.multi_cell(0, 6, showing)
            pdf.ln(2)

    pdf.output(filename)
    return filename


def export_csv(result_dict, filename="slab_design_results.csv"):
    """
    Save result dictionary to CSV file. Detailed steps are appended at end.
    """
    with open(filename, mode="w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["Parameter", "Value"])
        for key, value in result_dict.items():
            if key == "detailed_steps":
                continue
            if key == "warnings":
                continue
            writer.writerow([key, value])

        # Warnings
        writer.writerow([])
        writer.writerow(["Warnings", ""])
        if result_dict.get("warnings"):
            for w in result_dict["warnings"]:
                writer.writerow(["", w])

        # Detailed steps appended as text (optional)
        if result_dict.get("detailed_steps"):
            writer.writerow([])
            writer.writerow(["Detailed Steps", ""])
            for step in result_dict["detailed_steps"]:
                title = step.get("title", "")
                body = step.get("body", "").replace("\n", " | ")
                writer.writerow([title, body])

    return filename

